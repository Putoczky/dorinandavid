---
interface Props {
	class?: string;
	svgFile?: string;
}

const { class: className = '', svgFile = 'dom.svg' } = Astro.props;
---

<div class={`flex justify-center ${className}`} data-svg-container data-svg-file={svgFile}>
	<!-- SVG will be loaded here -->
</div>

<script>
	async function loadAndAnimateSVG(container: HTMLElement) {
		if (!container) return;

		const svgFile = container.getAttribute('data-svg-file') || 'dom.svg';

		try {
			const response = await fetch(`/${svgFile}`);
			const svgText = await response.text();
			
			const tempDiv = document.createElement('div');
			tempDiv.innerHTML = svgText;
			// Try to find SVG with class first, otherwise use the root SVG element
			let svg = tempDiv.querySelector('.svg-draw-animated') as SVGElement | null;
			if (!svg) {
				svg = tempDiv.querySelector('svg');
			}
			
			if (!svg) {
				console.error('SVG element not found');
				return;
			}
			
			// Add the class if it doesn't exist
			if (!svg.classList.contains('svg-draw-animated')) {
				svg.classList.add('svg-draw-animated');
			}

			container.innerHTML = '';
			
			// Hide SVG immediately to prevent flash
			if (svg instanceof SVGElement) {
				svg.style.opacity = '0';
				svg.style.display = 'block';
			}
			
			container.appendChild(svg);

			// Wait for SVG to be in DOM before calculating path lengths
			requestAnimationFrame(() => {
				requestAnimationFrame(() => {
					// Get all paths AFTER inserting into DOM (needed for getTotalLength to work)
					const paths = svg.querySelectorAll('path');
					
					if (paths.length === 0) {
						console.warn('No paths found in SVG');
						// Show SVG even if no paths
						if (svg instanceof SVGElement) {
							svg.style.opacity = '1';
						}
						return;
					}
					
					const duration = 6; // seconds
					
					// First, hide all paths immediately
					paths.forEach((path) => {
						path.style.opacity = '0';
					});
					
					// Force a reflow to ensure paths are hidden
					void svg.getBoundingClientRect();
					
					// Now set up animation state for each path
					paths.forEach((path) => {
						// Calculate path length first (must be in DOM)
						const pathLength = path.getTotalLength();
						
						if (pathLength === 0) {
							// If path has no length, make it visible immediately
							path.style.fillOpacity = '1';
							path.style.strokeOpacity = '1';
							path.style.opacity = '1';
							return;
						}

						// Set initial state for animation
						path.style.fillOpacity = '0';
						path.style.strokeOpacity = '1';
						
						// Calculate and set the dash properties for line drawing animation
						path.style.strokeDasharray = `${pathLength} ${pathLength}`;
						path.style.strokeDashoffset = String(pathLength);
						
						// Make path visible now that animation state is set
						path.style.opacity = '1';
						
						// Force reflow to ensure initial state is applied
						void path.getBoundingClientRect();
						
						// Animate using CSS animation
						path.style.animation = `draw-path ${duration}s ease-in-out forwards`;
					});
					
					// Show SVG now that all paths are set up
					if (svg instanceof SVGElement) {
						svg.style.opacity = '1';
					}
				});
			});
		} catch (error) {
			console.error('Error loading SVG:', error);
		}
	}

	function initAllSVGs() {
		const containers = document.querySelectorAll<HTMLElement>('[data-svg-container]');
		const animatedContainers = new Set<HTMLElement>();
		
		function checkAndAnimate() {
			containers.forEach((container) => {
				if (animatedContainers.has(container)) return;
				
				const card = container.closest('.card');
				if (!card) return;
				
				const cardRect = card.getBoundingClientRect();
				const viewportHeight = window.innerHeight;
				const cardCenter = cardRect.top + cardRect.height / 2;
				const viewportCenter = viewportHeight / 1.3;
				
				// Check if card center has reached or passed viewport center
				if (cardCenter <= viewportCenter && cardRect.bottom > 0 && cardRect.top < viewportHeight) {
					loadAndAnimateSVG(container);
					animatedContainers.add(container);
				}
			});
		}
		
		// Check on scroll and resize
		let ticking = false;
		function onScroll() {
			if (!ticking) {
				window.requestAnimationFrame(() => {
					checkAndAnimate();
					ticking = false;
				});
				ticking = true;
			}
		}
		
		window.addEventListener('scroll', onScroll, { passive: true });
		window.addEventListener('resize', onScroll, { passive: true });
		
		// Initial check
		checkAndAnimate();
	}

	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', initAllSVGs);
	} else {
		initAllSVGs();
	}
</script>

<style>
	.svg-draw-animated {
		display: block;
		width: 100%;
		height: 100%;
	}

	.svg-draw-animated path {
		fill-opacity: 0;
		stroke-opacity: 1;
		opacity: 0;
	}

	@keyframes draw-path {
		to {
			stroke-dashoffset: 0;
			fill-opacity: 1;
		}
	}
</style>

